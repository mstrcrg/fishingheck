<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fishing Heck</title>  
    <style>
        body { margin: 0; overflow: hidden; font-family: Arial, sans-serif; background-color: #333; color: white; }
        canvas { display: block; }
        #ui-container {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px;
            background-color: rgba(0,0,0,0.7);
            border-radius: 5px;
            z-index: 10;
            min-width: 220px;
        }
        /* Optional: Style for the game title if added to UI */
        #gameTitle { 
            margin-top: 0; 
            margin-bottom: 15px; 
            text-align: center; 
            font-size: 24px; 
            color: #FFEB3B; /* A nice golden yellow */
            text-shadow: 1px 1px 2px black; /* Simple shadow for readability */
        }
        .game-button { padding: 10px 15px; font-size: 16px; cursor: pointer; color: white; border: none; border-radius: 3px; display: block; margin-bottom: 10px; width: 100%; box-sizing: border-box; }
        #castButton { background-color: #4CAF50; } 
        #castButton:disabled { background-color: #aaa; cursor: not-allowed; } 
        #swatButton { background-color: #FFC107; display: none; }
        #swatButton:disabled { background-color: #aaa; cursor: not-allowed; }
        #fishInfo, #scoreBoard, #healthContainer { margin-top: 10px; font-size: 14px; }
        #healthBarOuter { width: 100%; height: 20px; background-color: #555; border-radius: 3px; overflow: hidden; margin-top: 5px; }
        #healthBarInner { width: 100%; height: 100%; background-color: #4CAF50; transition: width 0.3s ease-out, background-color 0.3s ease-out; }
        #gameOverScreen { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; text-align: center; z-index: 100; }
        #gameOverScreen h2 { font-size: 48px; color: #E53935; }
        #gameOverScreen p { font-size: 20px; }
        #shareButton { background-color: #009688; margin-top: 10px; }
        #shareFallbackMessage { font-size: 12px; margin-top: 5px; display: none; color: #ccc; }
    </style>
</head>
<body>
    <div id="ui-container">
        <h1 id="gameTitle">Fishing Heck</h1>
        <button id="castButton" class="game-button">Cast Line</button>
        <button id="swatButton" class="game-button">Swat Fly!</button>
        <div id="scoreBoard">Score: 0</div>
        <div id="healthContainer">
            Health:
            <div id="healthBarOuter"><div id="healthBarInner"></div></div>
        </div>
        <div id="fishInfo"></div>
    </div>
    <div id="gameOverScreen">
        <div>
            <h2>GAME OVER</h2>
            <p id="finalScoreMessage">Your final score: 0</p>
            <button id="restartButton" class="game-button" style="background-color: #1E88E5;">Restart Game</button>
            <button id="shareButton" class="game-button">Share Score</button>
            <p id="shareFallbackMessage"></p>
        </div>
    </div>

    <script type="importmap">
        { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js" } }
    </script>

    <script type="module">
        import * as THREE from 'three';

        const DEBUG_FLIES = true; 
        const DEBUG_REEL = true;

        let scene, camera, renderer;
        let water, bobber, currentCaughtFish;
        let gamePhase = 'idle'; 
        let biteTimeout, getAwayTimeout;
        let score = 0;

        const castButton = document.getElementById('castButton');
        const swatButton = document.getElementById('swatButton');
        const fishInfoDiv = document.getElementById('fishInfo');
        const scoreBoardDiv = document.getElementById('scoreBoard');
        const healthBarInner = document.getElementById('healthBarInner');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const finalScoreMessage = document.getElementById('finalScoreMessage');
        const restartButton = document.getElementById('restartButton');
        const shareButton = document.getElementById('shareButton');
        const shareFallbackMessage = document.getElementById('shareFallbackMessage');

        const MAX_HEALTH = 100;
        let playerHealth = MAX_HEALTH;
        const FLY_DAMAGE_PER_FLY_BASE = 5; 
        let flyDamageMultiplier = 1.0;
        const MAX_FLY_DAMAGE_MULTIPLIER = 3.0;
        const TIME_TO_INCREASE_FLY_DAMAGE_MS = 60000; 
        let flyDamageIncreaseIntervalId;

        let activeFlies = []; 
        const MAX_ACTIVE_FLIES = 4;
        const FLY_SCALE_MULTIPLIER = 1.8; 
        let initialFlySpawnChance = 0.3; 
        let subsequentFlySpawnChance = 0.4; 
        let considerInitialFlyTimeoutId;
        let considerAdditionalFlyTimeoutId;
        let flyDamageIntervalId; 
        const FLY_LIFESPAN_MS = 10000; 
        const FLY_DAMAGE_TICK_MS = 2000; 
        const ADD_FLY_DELAY_MS = 3000; 

        let clicksRequired = 0;
        let clicksMade = 0;
        let reelTimeoutId; 
        const REELING_TIME_LIMIT_MS = 8000; 

        const baseFishTypes = [
            { name: 'Minnow', baseSize: { length: 0.3, height: 0.15, width: 0.1 }, points: 10, clicksToReel: 1, colorPalette: ['#A0A0A0', '#B0B0B0', '#C0C0C0'] },
            { name: 'Goldfish', baseSize: { length: 0.4, height: 0.25, width: 0.15 }, points: 20, clicksToReel: 2, colorPalette: ['#FFA500', '#FFD700', '#FF8C00'] },
            { name: 'Trout', baseSize: { length: 0.6, height: 0.2, width: 0.15 }, points: 30, clicksToReel: 3, colorPalette: ['#B4E2A2', '#88C476', '#67A956'] },
            { name: 'Bass', baseSize: { length: 0.7, height: 0.3, width: 0.2 }, points: 50, clicksToReel: 4, colorPalette: ['#556B2F', '#6B8E23', '#8FBC8F'] },
            { name: 'Piranha', baseSize: { length: 0.45, height: 0.35, width: 0.12 }, points: 70, clicksToReel: 3, colorPalette: ['#C0C0C0', '#D3D3D3', '#DC143C'] },
            { name: 'Anglerfish', baseSize: { length: 0.8, height: 0.5, width: 0.4 }, points: 100, clicksToReel: 5, colorPalette: ['#4A3B31', '#6B5B50', '#2F251E'] }
        ];
        let lastCaughtFishData = null;

        class Fish extends THREE.Group { 
            constructor(fishTypeData) {
                super();
                this.fishTypeData = fishTypeData;
                const randomBodyColorHex = fishTypeData.colorPalette[Math.floor(Math.random() * fishTypeData.colorPalette.length)];
                const bodyMaterial = new THREE.MeshStandardMaterial({ color: randomBodyColorHex, roughness: 0.4, metalness: 0.1 });
                const eyeMaterial = new THREE.MeshStandardMaterial({ color: 0x000000, roughness: 0.1 });
                const bodyProportions = { l: 1, h: 0.4, w: 0.25 };
                const bodyGeom = new THREE.BoxGeometry(bodyProportions.l, bodyProportions.h, bodyProportions.w);
                this.body = new THREE.Mesh(bodyGeom, bodyMaterial); this.add(this.body);
                const tailGeom = new THREE.PlaneGeometry(bodyProportions.h * 1.2, bodyProportions.h * 0.8);
                this.tailFin = new THREE.Mesh(tailGeom, bodyMaterial);
                this.tailFin.position.x = -bodyProportions.l * 0.5 - (bodyProportions.h * 0.8 * 0.4);
                this.tailFin.rotation.y = Math.PI / 2; this.add(this.tailFin);
                const dorsalGeom = new THREE.PlaneGeometry(bodyProportions.l * 0.4, bodyProportions.h * 0.5);
                this.dorsalFin = new THREE.Mesh(dorsalGeom, bodyMaterial);
                this.dorsalFin.position.set(0, bodyProportions.h * 0.5 + (bodyProportions.h * 0.5 * 0.4), 0);
                this.dorsalFin.rotation.x = Math.PI / 2; this.add(this.dorsalFin);
                const pectoralGeom = new THREE.PlaneGeometry(bodyProportions.l * 0.25, bodyProportions.h * 0.3);
                this.leftPectoralFin = new THREE.Mesh(pectoralGeom, bodyMaterial);
                this.leftPectoralFin.position.set(bodyProportions.l * 0.15, -bodyProportions.h * 0.1, bodyProportions.w * 0.5);
                this.leftPectoralFin.rotation.y = -Math.PI / 4; this.add(this.leftPectoralFin);
                this.rightPectoralFin = this.leftPectoralFin.clone();
                this.rightPectoralFin.position.z = -bodyProportions.w * 0.5;
                this.rightPectoralFin.rotation.y = Math.PI / 4; this.add(this.rightPectoralFin);
                const eyeGeom = new THREE.SphereGeometry(bodyProportions.h * 0.1, 8, 8);
                this.leftEye = new THREE.Mesh(eyeGeom, eyeMaterial);
                this.leftEye.position.set(bodyProportions.l * 0.35, bodyProportions.h * 0.15, bodyProportions.w * 0.5);
                this.add(this.leftEye);
                this.rightEye = this.leftEye.clone();
                this.rightEye.position.z = -bodyProportions.w * 0.5; this.add(this.rightEye);
                const size = fishTypeData.baseSize;
                this.scale.set(size.length, size.height, size.width);
                this.rotation.y = -Math.PI / 2;
            }
        }
        
        function init() { 
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.6, 2); camera.lookAt(0, 1, -5);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight); document.body.appendChild(renderer.domElement);
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7); scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.2);
            directionalLight.position.set(5, 10, 7); scene.add(directionalLight);
            const waterGeometry = new THREE.PlaneGeometry(50, 50);
            const waterMaterial = new THREE.MeshStandardMaterial({ color: 0x006994, transparent: true, opacity: 0.85, roughness: 0.1, metalness: 0.2 });
            water = new THREE.Mesh(waterGeometry, waterMaterial);
            water.rotation.x = -Math.PI / 2; water.position.y = 0; scene.add(water);
            const bobberGeometry = new THREE.SphereGeometry(0.1, 16, 16);
            const bobberMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000, roughness: 0.5 });
            bobber = new THREE.Mesh(bobberGeometry, bobberMaterial);
            bobber.position.set(0, 0.5, 1); bobber.visible = false; scene.add(bobber);
            
            castButton.addEventListener('click', handlePrimaryAction);
            swatButton.addEventListener('click', handleSwatFly);
            restartButton.addEventListener('click', restartGame);
            shareButton.addEventListener('click', handleShareScore); 

            window.addEventListener('resize', onWindowResize, false);
            resetGameVariables(); updateUI(); animate();
        }
        function resetGameVariables() { 
            score = 0; playerHealth = MAX_HEALTH;
            gamePhase = 'idle'; 
            fishInfoDiv.textContent = "Welcome! Cast your line.";
            if (currentCaughtFish) { scene.remove(currentCaughtFish); currentCaughtFish = null; }
            bobber.visible = false; 
            clearAllFlyEvents(false); 
            clearTimeout(reelTimeoutId); 
            flyDamageMultiplier = 1.0; 
            if (DEBUG_FLIES) console.log(`[FlyDamageProgression] Reset. Multiplier: ${flyDamageMultiplier}`);
            clearInterval(flyDamageIncreaseIntervalId); 
            flyDamageIncreaseIntervalId = setInterval(increaseFlyDamage, TIME_TO_INCREASE_FLY_DAMAGE_MS); 
            shareFallbackMessage.style.display = 'none'; 
        }
        function increaseFlyDamage() { 
            if (gamePhase === 'gameover') {
                clearInterval(flyDamageIncreaseIntervalId);
                return;
            }
            if (flyDamageMultiplier < MAX_FLY_DAMAGE_MULTIPLIER) {
                flyDamageMultiplier += 0.25; 
                flyDamageMultiplier = Math.min(flyDamageMultiplier, MAX_FLY_DAMAGE_MULTIPLIER);
                if (DEBUG_FLIES) console.log(`[FlyDamageProgression] Fly damage multiplier increased to: ${flyDamageMultiplier.toFixed(2)}`);
            } else {
                 if (DEBUG_FLIES) console.log(`[FlyDamageProgression] Fly damage multiplier at max: ${flyDamageMultiplier.toFixed(2)}`);
                 clearInterval(flyDamageIncreaseIntervalId); 
            }
        }
        async function handleShareScore() { 
            const shareText = `I scored ${score} points in Fishing Heck! Can you beat my score?`; // Updated game name
            const gameUrl = window.location.href; // Assumes game is at current URL
            const shareData = {
                title: 'Fishing Heck - High Score!', // Updated game name
                text: shareText,
                url: gameUrl 
            };
            shareFallbackMessage.style.display = 'none'; 
            if (navigator.share) {
                try {
                    await navigator.share(shareData);
                    if (DEBUG_FLIES) console.log('Score shared successfully via Web Share API');
                    shareFallbackMessage.textContent = "Shared!";
                    shareFallbackMessage.style.display = 'block';
                } catch (err) {
                    if (DEBUG_FLIES) console.error('Error using Web Share API:', err);
                    if (err.name !== 'AbortError') { 
                         shareFallbackMessage.textContent = "Could not share. Try copying.";
                         shareFallbackMessage.style.display = 'block';
                         attemptCopyToClipboard(shareText + " Play at: " + gameUrl); 
                    }
                }
            } else {
                if (DEBUG_FLIES) console.log('Web Share API not supported, attempting clipboard fallback.');
                attemptCopyToClipboard(shareText + " Play at: " + gameUrl);
            }
        }
        function attemptCopyToClipboard(text) { 
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(text)
                    .then(() => {
                        if (DEBUG_FLIES) console.log('Score text copied to clipboard!');
                        shareFallbackMessage.textContent = "Score copied to clipboard!";
                        shareFallbackMessage.style.display = 'block';
                    })
                    .catch(err => {
                        if (DEBUG_FLIES) console.error('Failed to copy score text: ', err);
                        shareFallbackMessage.textContent = "Manual copy: Right-click input & copy.";
                        shareFallbackMessage.style.display = 'block';
                        prompt("Copy this text (Ctrl+C or Cmd+C):", text); 
                    });
            } else { 
                shareFallbackMessage.textContent = "Manual copy: Right-click input & copy.";
                shareFallbackMessage.style.display = 'block';
                prompt("Copy this text (Ctrl+C or Cmd+C):", text);
            }
        }

        function handlePrimaryAction() { 
            if (gamePhase === 'gameover') return;
            if (gamePhase === 'idle' || gamePhase === 'caught') {
                castLine();
            } else if (gamePhase === 'waiting') { 
                reelInEarly(); 
            } else if (gamePhase === 'biting') {
                startReelingProcess(); 
            } else if (gamePhase === 'reeling-struggle') {
                handleReelClick(); 
            }
        }

        function reelInEarly() { 
            if (gamePhase !== 'waiting') return;
            if (DEBUG_FLIES || DEBUG_REEL) console.log("[ReelDebug] Player reeled in early.");

            gamePhase = 'reeling-empty'; 
            fishInfoDiv.textContent = "Reeled in too soon... nothing there.";
            
            clearTimeout(biteTimeout); 
            clearAllFlyEvents(true);   

            bobber.visible = true; 
            const startPos = bobber.position.clone();
            const endPos = new THREE.Vector3(0, camera.position.y - 0.2, camera.position.z - 0.5); 
            const duration = 500; 
            let startTime = performance.now();

            function animateReelBack() {
                if (gamePhase !== 'reeling-empty') { 
                     if(bobber) bobber.visible = false; 
                     return;
                }
                let elapsedTime = performance.now() - startTime;
                let progress = Math.min(elapsedTime / duration, 1);
                if(bobber) {
                    bobber.position.lerpVectors(startPos, endPos, progress);
                    bobber.position.y = startPos.y + Math.sin(progress * Math.PI) * 0.3; 
                }
                if (progress < 1) {
                    requestAnimationFrame(animateReelBack);
                } else {
                    if(bobber) bobber.visible = false;
                    gamePhase = 'idle'; 
                    fishInfoDiv.textContent = "Nothing on the line. Try casting again!";
                    updateUI();
                }
            }
            animateReelBack();
            updateUI(); 
        }

        function castLine() { 
            if (gamePhase === 'gameover' || gamePhase === 'casting' || gamePhase === 'waiting' || gamePhase === 'reeling-struggle' || gamePhase === 'reeling-landing' || gamePhase === 'reeling-empty') return;
            if (currentCaughtFish) { scene.remove(currentCaughtFish); currentCaughtFish = null; }
            clearAllFlyEvents(false); 
            clearTimeout(reelTimeoutId);
            gamePhase = 'casting'; fishInfoDiv.textContent = 'Casting...';
            bobber.visible = true; bobber.position.set(0, 0.5, 1);
            bobber.material.color.set(0xff0000); 
            let castTargetZ = -(Math.random() * 4 + 3);
            let castDuration = 1000, startTime = performance.now();
            function animateCast() {
                if (gamePhase !== 'casting') return;
                let progress = Math.min((performance.now() - startTime) / castDuration, 1);
                bobber.position.z = 1 + progress * (castTargetZ - 1);
                bobber.position.y = 0.5 - 0.45 * Math.sin(progress * Math.PI);
                if (progress < 1) requestAnimationFrame(animateCast);
                else {
                    bobber.position.y = 0.05; 
                    gamePhase = 'waiting'; 
                    fishInfoDiv.textContent = 'Waiting for a bite...';
                    startWaitForBite();
                    if (DEBUG_FLIES) console.log("[FlyDebug] castLine (animateCast end): Explicitly calling scheduleInitialFlyConsideration as gamePhase is now 'waiting'.");
                    scheduleInitialFlyConsideration(); 
                }
                updateUI();
            }
            animateCast(); updateUI();
        }
        function startWaitForBite() { 
            if (gamePhase !== 'waiting') return;
            const waitTime = Math.random() * 7000 + 3000;
            clearTimeout(biteTimeout);
            biteTimeout = setTimeout(() => {
                if (gamePhase === 'waiting') { fishBites(); }
            }, waitTime);
        }
        let bobberBobbingTime = 0;
        function animateBobberWaiting() { 
            if (gamePhase === 'waiting') {
                bobberBobbingTime += 0.1;
                bobber.position.y = 0.05 + Math.sin(bobberBobbingTime) * 0.02;
            }
        }
        function fishBites() { 
            if (gamePhase !== 'waiting') return;
            if (DEBUG_FLIES && activeFlies.length > 0) console.log("[FlyDebug] fishBites: Flies are active during bite!");
            clearTimeout(biteTimeout); 
            gamePhase = 'biting'; 
            fishInfoDiv.textContent = 'BITE! Reel it in!';
            bobber.material.color.set(0xffff00); 
            let dipStartTime = performance.now(); 
            const initialBobberY = bobber.position.y;
            function animateDip() {
                if (gamePhase !== 'biting') { 
                    if (bobber.visible) bobber.material.color.set(0xff0000); 
                    bobber.position.y = initialBobberY; return; 
                }
                let t = (performance.now() - dipStartTime) / 200;
                bobber.position.y = initialBobberY - Math.sin(Math.min(t,1) * Math.PI) * 0.1;
                if (t < 1.5) requestAnimationFrame(animateDip);
                else if (gamePhase === 'biting') bobber.position.y = initialBobberY - 0.1; 
            }
            animateDip();
            clearTimeout(getAwayTimeout);
            getAwayTimeout = setTimeout(() => { 
                if (gamePhase === 'biting') { fishGotAway(); }
            }, 2000 + Math.random() * 1000);
            updateUI();
        }
        function startReelingProcess() { 
            if (gamePhase !== 'biting') return;
            clearTimeout(getAwayTimeout); 
            gamePhase = 'reeling-struggle';
            bobber.visible = false; 
            generateAndShowFish(); 
            clicksRequired = lastCaughtFishData.clicksToReel || 3; 
            clicksMade = 0;
            fishInfoDiv.textContent = `It's a fighter! Keep reeling!`;
            currentCaughtFish.position.copy(bobber.position); 
            currentCaughtFish.position.y -= 0.3; 
            currentCaughtFish.lookAt(new THREE.Vector3(camera.position.x, currentCaughtFish.position.y, camera.position.z + 10)); 
            currentCaughtFish.visible = true;
            if(DEBUG_REEL) console.log(`[ReelDebug] Starting reel struggle. Clicks required: ${clicksRequired} for ${lastCaughtFishData.name}`);
            clearTimeout(reelTimeoutId);
            reelTimeoutId = setTimeout(() => {
                if (gamePhase === 'reeling-struggle') {
                    if(DEBUG_REEL) console.log("[ReelDebug] Reeling timed out! Fish got away (line snapped).");
                    fishInfoDiv.textContent = "Aargh! It was too strong and snapped the line!";
                    lineSnapped();
                }
            }, REELING_TIME_LIMIT_MS + (clicksRequired * 500)); 
            updateUI();
        }
        function handleReelClick() { 
            if (gamePhase !== 'reeling-struggle') return;
            clicksMade++;
            if(DEBUG_REEL) console.log(`[ReelDebug] Reel click! ${clicksMade}/${clicksRequired}`);
            if (currentCaughtFish) { 
                const originalRotationZ = currentCaughtFish.rotation.z;
                currentCaughtFish.rotation.z += (Math.random() - 0.5) * 0.2;
                setTimeout(() => { if(currentCaughtFish && currentCaughtFish.visible) currentCaughtFish.rotation.z = originalRotationZ; }, 100);
            }
            if (clicksMade >= clicksRequired) {
                clearTimeout(reelTimeoutId); 
                if(DEBUG_REEL) console.log("[ReelDebug] All clicks made! Proceeding to land fish.");
                landTheFish();
            } else {
                fishInfoDiv.textContent = `Pull! Keep reeling!`;
            }
            updateUI();
        }
        function lineSnapped() { 
            if(DEBUG_REEL) console.log("[ReelDebug] Line snapped function called.");
            gamePhase = 'idle'; 
            if(bobber) bobber.visible = false; 
            if (currentCaughtFish) {
                scene.remove(currentCaughtFish); 
                currentCaughtFish = null;
            }
            fishInfoDiv.textContent = "Line snapped! The fish got away."; 
            updateUI();
        }
        function landTheFish() { 
            gamePhase = 'reeling-landing'; 
            fishInfoDiv.textContent = 'Got it! Landing the fish!';
            let reelStartTime = performance.now();
            const reelDuration = 1500;
            const startPos = currentCaughtFish.position.clone();
            const targetPos = new THREE.Vector3(
                camera.position.x + Math.sin(camera.rotation.y) * 0.5, 
                camera.position.y - 0.5, 
                camera.position.z - 1.5  
            );
            function animateLand() {
                if (gamePhase !== 'reeling-landing') return;
                let elapsedTime = performance.now() - reelStartTime;
                let progress = Math.min(elapsedTime / reelDuration, 1);
                if (currentCaughtFish) { 
                    currentCaughtFish.position.lerpVectors(startPos, targetPos, progress);
                    currentCaughtFish.rotation.y += 0.1; 
                    currentCaughtFish.lookAt(camera.position);
                }
                if (progress < 1) {
                    requestAnimationFrame(animateLand);
                } else {
                    fishCaught(); 
                }
                updateUI();
            }
            animateLand();
            updateUI();
        }
        function generateAndShowFish() { 
            if (currentCaughtFish) { 
                scene.remove(currentCaughtFish);
                currentCaughtFish = null; 
            }
            const fishType = baseFishTypes[Math.floor(Math.random() * baseFishTypes.length)];
            lastCaughtFishData = {
                name: fishType.name,
                size: (fishType.baseSize.length * 100 * (1 + (Math.random()-0.5)*0.2)).toFixed(1),
                points: fishType.points,
                clicksToReel: fishType.clicksToReel 
            };
            currentCaughtFish = new Fish(fishType); 
            lastCaughtFishData.colorName = getColorNameFromHex(currentCaughtFish.body.material.color.getHexString());
            currentCaughtFish.visible = false; 
            scene.add(currentCaughtFish);
             if(DEBUG_REEL) console.log(`[ReelDebug] Generated ${lastCaughtFishData.name}, requires ${lastCaughtFishData.clicksToReel} clicks.`);
        }
        function getColorNameFromHex(hexString) { 
            const r = parseInt(hexString.substring(1, 3), 16);
            const g = parseInt(hexString.substring(3, 5), 16);
            const b = parseInt(hexString.substring(5, 7), 16);
            if (r > 200 && g > 100 && b < 100) return "Orangey";
            if (r > 200 && g > 200 && b < 100) return "Yellowish";
            if (g > 150 && r < 100 && b < 100) return "Greenish";
            if (b > 150 && r < 100 && g < 100) return "Blueish";
            if (r > 150 && g < 100 && b > 150) return "Purplish";
            if (r > 150 && g > 150 && b > 150) return "Silvery";
            if (r < 100 && g < 100 && b < 100) return "Dark";
            return "Colorful";
        }
        function fishCaught() { 
            if (gamePhase !== 'reeling-landing') return;
            gamePhase = 'caught'; 
            score += lastCaughtFishData.points; 
            fishInfoDiv.innerHTML = `You caught a ${lastCaughtFishData.colorName} ${lastCaughtFishData.name}! <br>Size: ${lastCaughtFishData.size}cm. Clicks: ${lastCaughtFishData.clicksToReel}. <br>Points: ${lastCaughtFishData.points}`;
            updateUI(); 
        }
        function fishGotAway() { 
            if (gamePhase !== 'biting') return; 
            gamePhase = 'waiting'; 
            fishInfoDiv.textContent = 'Oh no, it spit the hook! Still waiting...';
            bobber.visible = true; 
            bobber.material.color.set(0xff0000); 
            updateUI();
            startWaitForBite(); 
            if (activeFlies.length === 0 && gamePhase === 'waiting') { 
                 if (DEBUG_FLIES) console.log("[FlyDebug] fishGotAway (spit hook): No flies active, explicitly calling scheduleInitialFlyConsideration.");
                 scheduleInitialFlyConsideration();
            } else if (activeFlies.length > 0 && activeFlies.length < MAX_ACTIVE_FLIES && gamePhase === 'waiting') {
                 if (DEBUG_FLIES) console.log("[FlyDebug] fishGotAway (spit hook): Flies are active, calling scheduleAdditionalFlyConsideration.");
                 scheduleAdditionalFlyConsideration();
            }
        }
        function updateHealthUI() { 
            const healthPercentage = (playerHealth / MAX_HEALTH) * 100;
            healthBarInner.style.width = `${healthPercentage}%`;
            if (healthPercentage < 30) healthBarInner.style.backgroundColor = '#E53935'; 
            else if (healthPercentage < 60) healthBarInner.style.backgroundColor = '#FFC107'; 
            else healthBarInner.style.backgroundColor = '#4CAF50'; 
        }
        function takeDamage(amount) { 
            if (gamePhase === 'gameover') return;
            playerHealth -= amount;
            playerHealth = Math.max(0, playerHealth);
            if (amount > 0) fishInfoDiv.textContent = `Ouch! ${activeFlies.length > 1 ? 'Flies are' : 'A fly is'} biting you! -${amount} Health.`;
            updateHealthUI();
            if (playerHealth <= 0) {
                triggerGameOver();
            }
        }
        function triggerGameOver() { 
            gamePhase = 'gameover'; 
            clearAllFlyEvents(false); 
            clearTimeout(biteTimeout); clearTimeout(getAwayTimeout); clearTimeout(reelTimeoutId);
            clearInterval(flyDamageIncreaseIntervalId); 
            bobber.visible = false;
            if (currentCaughtFish) scene.remove(currentCaughtFish); currentCaughtFish = null;
            finalScoreMessage.textContent = `Your final score: ${score}`;
            gameOverScreen.style.display = 'flex';
            fishInfoDiv.textContent = "Game Over! Better luck next time.";
            updateUI();
        }
        function restartGame() { 
            gameOverScreen.style.display = 'none';
            resetGameVariables(); 
            updateUI();
        }
        function createSingleFlyInstance() { 
            const bodySize = 0.03 * FLY_SCALE_MULTIPLIER;
            const wingWidth = 0.05 * FLY_SCALE_MULTIPLIER;
            const wingHeight = 0.02 * FLY_SCALE_MULTIPLIER;
            const flyBodyGeom = new THREE.SphereGeometry(bodySize, 8, 6);
            const flyMaterial = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.8 });
            const flyBody = new THREE.Mesh(flyBodyGeom, flyMaterial);
            const wingGeom = new THREE.PlaneGeometry(wingWidth, wingHeight);
            const wingMaterial = new THREE.MeshStandardMaterial({ color: 0x999999, transparent: true, opacity: 0.6, side: THREE.DoubleSide });
            const leftWing = new THREE.Mesh(wingGeom, wingMaterial);
            leftWing.position.set(-bodySize * 0.8, bodySize * 0.3, 0);
            leftWing.rotation.z = Math.PI / 5;
            const rightWing = new THREE.Mesh(wingGeom, wingMaterial);
            rightWing.position.set(bodySize * 0.8, bodySize * 0.3, 0);
            rightWing.rotation.z = -Math.PI / 5;
            const flyInstance = new THREE.Group();
            flyInstance.add(flyBody);
            flyInstance.add(leftWing);
            flyInstance.add(rightWing);
            flyInstance.visible = false; 
            scene.add(flyInstance);
            return flyInstance;
        }
        function scheduleInitialFlyConsideration() { 
            if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: Entry. gamePhase=${gamePhase}, activeFlies.length=${activeFlies.length}`);
            if (gamePhase !== 'waiting' || activeFlies.length > 0 || gamePhase === 'gameover') { 
                if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: Conditions NOT MET (gamePhase: ${gamePhase}, flies: ${activeFlies.length}), returning.`);
                return;
            }
            clearTimeout(considerInitialFlyTimeoutId);
            const delay = (Math.random() * 2000 + 1000) / (DEBUG_FLIES ? 2 : 1) ; 
            if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: Setting timeout for ${delay.toFixed(0)}ms`);
            considerInitialFlyTimeoutId = setTimeout(() => {
                if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: TIMEOUT FIRED. gamePhase=${gamePhase}, activeFlies.length=${activeFlies.length}`);
                if (gamePhase === 'waiting' && activeFlies.length === 0) { 
                    const roll = Math.random();
                    if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: Rolled ${roll.toFixed(2)} vs chance ${initialFlySpawnChance}`);
                    if (roll < initialFlySpawnChance) {
                        if (DEBUG_FLIES) console.log("[FlyDebug] scheduleInitialFlyConsideration: Spawning new fly!");
                        spawnNewFly();
                    } else {
                        if (DEBUG_FLIES) console.log("[FlyDebug] scheduleInitialFlyConsideration: Missed chance, rescheduling initial.");
                        scheduleInitialFlyConsideration(); 
                    }
                } else {
                    if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleInitialFlyConsideration: Conditions in timeout not met for spawning/rescheduling. gamePhase=${gamePhase}, flies=${activeFlies.length}`);
                }
            }, delay); 
        }
        function scheduleAdditionalFlyConsideration() { 
            if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: Entry. gamePhase=${gamePhase}, activeFlies.length=${activeFlies.length}, MAX_FLIES=${MAX_ACTIVE_FLIES}`);
            if (gamePhase !== 'waiting' || activeFlies.length === 0 || activeFlies.length >= MAX_ACTIVE_FLIES || gamePhase === 'gameover') { 
                if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: Conditions NOT MET (gamePhase: ${gamePhase}, flies: ${activeFlies.length}/${MAX_ACTIVE_FLIES}), returning.`);
                return;
            }
            clearTimeout(considerAdditionalFlyTimeoutId);
            const delay = (ADD_FLY_DELAY_MS + Math.random() * 2000) / (DEBUG_FLIES ? 2 : 1); 
            if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: Setting timeout for ${delay.toFixed(0)}ms`);
            considerAdditionalFlyTimeoutId = setTimeout(() => {
                if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: TIMEOUT FIRED. gamePhase=${gamePhase}, activeFlies.length=${activeFlies.length}`);
                if (gamePhase === 'waiting' && activeFlies.length > 0 && activeFlies.length < MAX_ACTIVE_FLIES) { 
                    const roll = Math.random();
                     if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: Rolled ${roll.toFixed(2)} vs chance ${subsequentFlySpawnChance}`);
                    if (roll < subsequentFlySpawnChance) {
                        if (DEBUG_FLIES) console.log("[FlyDebug] scheduleAdditionalFlyConsideration: Spawning additional fly!");
                        spawnNewFly();
                    } else {
                         if (DEBUG_FLIES) console.log("[FlyDebug] scheduleAdditionalFlyConsideration: Missed chance, rescheduling additional.");
                        scheduleAdditionalFlyConsideration(); 
                    }
                } else {
                     if (DEBUG_FLIES) console.log(`[FlyDebug] scheduleAdditionalFlyConsideration: Conditions in timeout not met for spawning/rescheduling. gamePhase=${gamePhase}, flies=${activeFlies.length}`);
                }
            }, delay);
        }
        function spawnNewFly() { 
            if (DEBUG_FLIES) console.log(`[FlyDebug] spawnNewFly: Attempting. activeFlies.length=${activeFlies.length}, MAX_FLIES=${MAX_ACTIVE_FLIES}, gamePhase=${gamePhase}`);
            if (activeFlies.length >= MAX_ACTIVE_FLIES || gamePhase !== 'waiting' || gamePhase === 'gameover') {
                if (DEBUG_FLIES) console.log("[FlyDebug] spawnNewFly: Conditions not met, returning early.");
                return;
            }
            const newFlyMesh = createSingleFlyInstance();
            newFlyMesh.visible = true; 
            if (DEBUG_FLIES) console.log("[FlyDebug] spawnNewFly: Fly mesh created and set to visible.");
            const bobberDepth = bobber.visible ? bobber.position.z : camera.position.z - 3; 
            newFlyMesh.position.x = camera.position.x + (Math.random() - 0.5) * 2.5;
            newFlyMesh.position.y = camera.position.y + (Math.random() - 0.5) * 1.5;
            newFlyMesh.position.z = bobberDepth + (Math.random() - 0.5) * 1.5;
            if (DEBUG_FLIES) console.log("[FlyDebug] spawnNewFly: Fly position set to:", newFlyMesh.position.toArray().map(p=>p.toFixed(2)));
            const flyId = THREE.MathUtils.generateUUID();
            const despawnTimeoutId = setTimeout(() => removeFlyById(flyId, false), FLY_LIFESPAN_MS);
            activeFlies.push({ 
                id: flyId, mesh: newFlyMesh, targetPos: new THREE.Vector3().copy(newFlyMesh.position), 
                spawnTime: Date.now(), despawnTimeoutId: despawnTimeoutId
            });
            if (DEBUG_FLIES) console.log(`[FlyDebug] spawnNewFly: Pushed new fly. ID: ${flyId}. Total active: ${activeFlies.length}`);
            if (activeFlies.length === 1) { 
                fishInfoDiv.textContent = "A pesky fly appeared! Swat it!";
                if (!flyDamageIntervalId) {
                    if (DEBUG_FLIES) console.log("[FlyDebug] spawnNewFly: Starting damage interval.");
                    flyDamageIntervalId = setInterval(() => {
                        if (activeFlies.length > 0 && gamePhase !== 'gameover') {
                            const actualDamagePerFly = FLY_DAMAGE_PER_FLY_BASE * flyDamageMultiplier; 
                            const totalDamage = Math.ceil(actualDamagePerFly * activeFlies.length); 
                            if (DEBUG_FLIES) console.log(`[FlyDebug] Damage interval: BaseDmg=${FLY_DAMAGE_PER_FLY_BASE}, Multiplier=${flyDamageMultiplier.toFixed(2)}, ActualPerFly=${actualDamagePerFly.toFixed(2)}, TotalDealing=${totalDamage}. Active flies: ${activeFlies.length}`);
                            takeDamage(totalDamage);
                        }
                    }, FLY_DAMAGE_TICK_MS);
                }
            } else {
                 fishInfoDiv.textContent = `More flies! (${activeFlies.length}) Swat them!`;
            }
            updateUI();
            if (DEBUG_FLIES) console.log("[FlyDebug] spawnNewFly: Calling scheduleAdditionalFlyConsideration.");
            scheduleAdditionalFlyConsideration(); 
        }
        function animateActiveFlies() { 
            if (activeFlies.length === 0) return;
            activeFlies.forEach(flyData => {
                const flyMesh = flyData.mesh;
                if (!flyMesh.visible) return; 
                if (Math.random() < 0.05) {
                    const targetBobberPos = bobber.visible ? bobber.position : new THREE.Vector3(camera.position.x, camera.position.y -0.5, camera.position.z -3);
                    flyData.targetPos.x = targetBobberPos.x + (Math.random() - 0.5) * 2;
                    flyData.targetPos.y = targetBobberPos.y + 0.5 + (Math.random() - 0.5) * 1;
                    flyData.targetPos.z = targetBobberPos.z + (Math.random() - 0.5) * 1;
                }
                flyMesh.position.lerp(flyData.targetPos, 0.02);
                flyMesh.position.x += (Math.random() - 0.5) * 0.04; 
                flyMesh.position.y += (Math.random() - 0.5) * 0.04;
                flyMesh.position.z += (Math.random() - 0.5) * 0.04;
                const baseWingAngle = Math.PI / 5;
                const flapAmount = Math.PI / 7 * Math.sin(performance.now() * 0.06);
                flyMesh.children[1].rotation.z = baseWingAngle + flapAmount; 
                flyMesh.children[2].rotation.z = -baseWingAngle - flapAmount; 
                flyMesh.lookAt(camera.position);
            });
        }
        function handleSwatFly() { 
            if (activeFlies.length === 0 || gamePhase === 'gameover') return;
            const swattedFly = activeFlies.shift(); 
            if (swattedFly) {
                if (DEBUG_FLIES) console.log(`[FlyDebug] handleSwatFly: Swatted fly ID ${swattedFly.id}. Remaining: ${activeFlies.length}`);
                fishInfoDiv.textContent = `Swatted a fly! ${activeFlies.length} remaining.`;
                scene.remove(swattedFly.mesh);
                clearTimeout(swattedFly.despawnTimeoutId);
            }
            if (activeFlies.length === 0) {
                if (DEBUG_FLIES) console.log("[FlyDebug] handleSwatFly: All flies swatted. Clearing damage interval.");
                fishInfoDiv.textContent = "All flies swatted!";
                clearInterval(flyDamageIntervalId); flyDamageIntervalId = null;
                clearTimeout(considerAdditionalFlyTimeoutId); 
                setTimeout(() => { 
                    if (gamePhase === 'waiting') { 
                        if (DEBUG_FLIES) console.log("[FlyDebug] handleSwatFly: Respite over, and gamePhase is 'waiting'. Calling scheduleInitialFlyConsideration.");
                        scheduleInitialFlyConsideration();
                    } else {
                        if (DEBUG_FLIES) console.log(`[FlyDebug] handleSwatFly: Respite over, but gamePhase is '${gamePhase}' (not 'waiting'), not rescheduling flies.`);
                    }
                }, 4000); 
            } else { 
                if (DEBUG_FLIES) console.log("[FlyDebug] handleSwatFly: Flies remain. Calling scheduleAdditionalFlyConsideration.");
                scheduleAdditionalFlyConsideration(); 
            }
            updateUI();
        }
        function removeFlyById(flyId, wasSwatted) { 
            const index = activeFlies.findIndex(f => f.id === flyId);
            if (index > -1) {
                const removedFly = activeFlies.splice(index, 1)[0];
                if (DEBUG_FLIES) console.log(`[FlyDebug] removeFlyById: Removing fly ID ${removedFly.id}. Was swatted: ${wasSwatted}. Remaining: ${activeFlies.length}`);
                scene.remove(removedFly.mesh);
                clearTimeout(removedFly.despawnTimeoutId); 
                if (!wasSwatted) { 
                    fishInfoDiv.textContent = `A fly got bored and left. ${activeFlies.length} remaining.`;
                }
            } else {
                if (DEBUG_FLIES) console.warn(`[FlyDebug] removeFlyById: Could not find fly ID ${flyId} to remove.`);
            }
            if (activeFlies.length === 0) { 
                if (DEBUG_FLIES) console.log("[FlyDebug] removeFlyById: Last fly removed. Clearing damage interval.");
                if (!wasSwatted) fishInfoDiv.textContent = "The last fly left on its own.";
                clearInterval(flyDamageIntervalId); flyDamageIntervalId = null;
                clearTimeout(considerAdditionalFlyTimeoutId); 
                if (gamePhase === 'waiting') { 
                    if (DEBUG_FLIES) console.log("[FlyDebug] removeFlyById: GamePhase is 'waiting'. Calling scheduleInitialFlyConsideration after last fly removed.");
                    scheduleInitialFlyConsideration(); 
                } else {
                     if (DEBUG_FLIES) console.log(`[FlyDebug] removeFlyById: GamePhase is '${gamePhase}' (not 'waiting'). Not rescheduling initial flies.`);
                }
            }
            updateUI();
        }
        function clearAllFlyEvents(triggeredByPlayerAction) { 
            const fliesBeforeClearCount = activeFlies.length;
            if (DEBUG_FLIES) console.log(`[FlyDebug] clearAllFlyEvents: Called. PlayerAction: ${triggeredByPlayerAction}. Flies before clear: ${fliesBeforeClearCount}. Current gamePhase: ${gamePhase}`);
            activeFlies.forEach(flyData => {
                scene.remove(flyData.mesh); clearTimeout(flyData.despawnTimeoutId);
            });
            activeFlies = []; 
            clearInterval(flyDamageIntervalId); flyDamageIntervalId = null;
            clearTimeout(considerInitialFlyTimeoutId); clearTimeout(considerAdditionalFlyTimeoutId);
            if (triggeredByPlayerAction && fliesBeforeClearCount > 0 && 
                (gamePhase === 'reeling-empty' || gamePhase === 'biting' || gamePhase === 'reeling-struggle' || gamePhase === 'reeling-landing')) {
                 if (DEBUG_FLIES) console.log("[FlyDebug] clearAllFlyEvents: Flies potentially scattered by player action.");
            }
            updateUI(); 
        }

        function updateUI() { 
            scoreBoardDiv.textContent = `Score: ${score}`;
            updateHealthUI();
            const isBobberCastAndActive = (gamePhase === 'waiting' || gamePhase === 'biting' || gamePhase === 'reeling-struggle');
            
            if (gamePhase === 'gameover') {
                castButton.style.display = 'none'; 
                swatButton.style.display = 'none';
                shareButton.style.display = 'block'; 
                return;
            } else {
                shareButton.style.display = 'none'; 
                shareFallbackMessage.style.display = 'none'; 
            }

            castButton.style.display = 'block';

            if (isBobberCastAndActive) {
                if (gamePhase === 'reeling-struggle') {
                    castButton.textContent = `Reel! [${clicksMade}/${clicksRequired}]`;
                } else { // 'waiting' or 'biting'
                    castButton.textContent = 'Reel In';
                }
                castButton.style.backgroundColor = '#4CAF50'; 
                castButton.disabled = false; 
            } else if (gamePhase === 'reeling-landing' || gamePhase === 'reeling-empty' || gamePhase === 'casting') {
                let phaseText = gamePhase.charAt(0).toUpperCase() + gamePhase.slice(1);
                if(gamePhase === 'reeling-landing') phaseText = "Landing Fish";
                else if (gamePhase === 'reeling-empty') phaseText = "Reeling In"; 
                castButton.textContent = phaseText + '...';
                castButton.style.backgroundColor = '#aaa'; 
                castButton.disabled = true;
            } else { // idle, caught
                castButton.textContent = 'Cast Line';
                castButton.style.backgroundColor = '#4CAF50'; 
                castButton.disabled = false;
            }
            
            swatButton.style.display = activeFlies.length > 0 ? 'block' : 'none';
        }
        function onWindowResize() { 
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() { 
            requestAnimationFrame(animate);
            if (gamePhase === 'waiting') animateBobberWaiting();
            if (activeFlies.length > 0) animateActiveFlies(); 
            if (gamePhase === 'caught' && currentCaughtFish && currentCaughtFish.visible) { 
                 currentCaughtFish.rotation.y += 0.005;
                 currentCaughtFish.position.y = camera.position.y - 0.5 + Math.sin(performance.now() * 0.001) * 0.05;
            }
            renderer.render(scene, camera);
        }
        init();
    </script>
</body>
</html>